<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XTL: Parsing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XTL
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">eXtended Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__c_Dev_src_github_xtl_docs_Parsing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Parsing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Parsing is an extensive subject and a frequent stumbling block of even experienced engineers. Due to the repetitive nature of parsing code, the volume of the points of failure and the frequently changing format of inputs, parsing code is often a significant resource sink for many software projects.</p>
<p>Parsing is frequently outlined with a grammar specification in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Backus-Naur Form (BNF)</a> which defines the terminals and non-terminals that must be tagged in the input stream. Some tools accept the BNF grammar directly as input and generate all the parsing code as output. These tools are called parser-generators and they can save a lot of pain and time. Though not limited to accepting BNF exclusively as inputs, some parser-generates have custom language specifications or decorate BNF with various text handling code, the basic product is normally the same: some language specification is taken as input and all the boiler plate parsing code is generated as output. In most cases the resulting generated parser includes some interfaces for the library consumer to interrogate the parsed sources. Frequently, the parsed inputs are then feed as inputs to another stage which produces an <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Abstract Syntax Tree (AST)</a>. The AST is most often the primary model that applications use to work with the inputs.</p>
<p>Some applications do not use generated parsers nor an AST. Some apps do not even abstract the parsing code from the processing code and will instead parse the inputs directly in-line with application logic. For all except the most trivial applications this is a recipe for disaster. Abstracting the two tasks is almost always the preferred method. However, doing things 'right' and adhering to best practice is also time consuming. For example, using the traditional GNU tools to handle parsing is an entire discipline of it's own that complicates the build process and requires a modicum of domain expertise before any application logic is ever addressed. Modern tools such as Boost::Spirit and Antlr suffer from the same problem of requiring a detailed study of the library to get a simple parse task accomplished.</p>
<p>When the introduction of a tool that is intended to simplify a problem makes the problem more complicated the tool looses it's utility and usefullness. Since using these tools require a significant investiment to learn and use properly it's no surprise that so many developers just opt to hand-roll a parser rather than learn yet another library. With all that said I introduce yet another library.</p>
<h2>Introduction </h2>
<p>XTL::parse uses template meta-programming techniques to generate parse trees from a grammar specification. The grammar specification is written in C++ templates. The library is header-only and the parse trees are generated at compile time so there's no libraries to link to and no external tools to run as part of the build process. A unique feature of XTL::parse is that the grammar specification gets instantiated as the [AST] when the parse is successful which eleminates the need for an additional import step which is frequent of other similar tools. XTL::parse is a simple LL(k) parser that encourages embedding the grammar specification in the AST for simplicity and clarity.</p>
<p>To illustrate the entire process, here's a simple BNF grammar describing the command line syntax of example_parse1.cpp:</p>
<div class="fragment"><div class="line"><span class="comment">//terminals</span></div><div class="line">&lt;red&gt;           := <span class="stringliteral">&#39;red&#39;</span></div><div class="line">&lt;green&gt;         := <span class="stringliteral">&#39;green&#39;</span></div><div class="line">&lt;blue&gt;          := <span class="stringliteral">&#39;blue&#39;</span></div><div class="line">&lt;one&gt;           := <span class="charliteral">&#39;1&#39;</span></div><div class="line">&lt;three&gt;         := <span class="charliteral">&#39;3&#39;</span></div><div class="line">&lt;five&gt;          := <span class="charliteral">&#39;5&#39;</span></div><div class="line">&lt;dash_color&gt;    := <span class="stringliteral">&#39;--color=&#39;</span></div><div class="line">&lt;dash_prime&gt;    := <span class="stringliteral">&#39;--prime=&#39;</span></div><div class="line"><span class="comment">//rules</span></div><div class="line">&lt;rgb&gt;           := &lt;red&gt; | &lt;green&gt; | &lt;blue&gt;</div><div class="line">&lt;prime_num&gt;     := &lt;one&gt; | &lt;three&gt; | &lt;five&gt;</div><div class="line">&lt;color_param&gt;   := &lt;dash_color&gt; &lt;rgb&gt;</div><div class="line">&lt;prime_param&gt;   := &lt;dash_prime&gt; &lt;prime_num&gt;</div><div class="line">&lt;parameter&gt;     := &lt;color_param&gt; | &lt;prime_param&gt;</div></div><!-- fragment --> <blockquote class="doxtable">
<p>If the intention of this BNF syntax is unclear there are plenty of tutorials on the web. </p>
</blockquote>
<p>This is the sort of BNF that is frequently encountered in RFCs, white papers, programming language and protocol specifications. It maps into a XTL::parse grammar specification as:</p>
<div class="fragment"><div class="line"><span class="comment">//termnals</span></div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(red, <span class="stringliteral">&quot;red&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(green, <span class="stringliteral">&quot;green&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(blue, <span class="stringliteral">&quot;blue&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(one, <span class="stringliteral">&quot;1&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(three, <span class="stringliteral">&quot;3&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(five, <span class="stringliteral">&quot;5&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(dash_color, <span class="stringliteral">&quot;--color=&quot;</span>);</div><div class="line"><a class="code" href="group___parsing.html#ga6b587a2620e69f0a0168131a13f6c070">STRING</a>(dash_prime, <span class="stringliteral">&quot;--prime=&quot;</span>);</div><div class="line"><span class="comment">//rules</span></div><div class="line"><span class="keyword">using</span> rgb = or_&lt;red, green, blue&gt;;</div><div class="line"><span class="keyword">using</span> prime_num = or_&lt;one, three, five&gt;;</div><div class="line"><span class="keyword">using</span> color_param = and_&lt;dash_color, rgb&gt;;</div><div class="line"><span class="keyword">using</span> prime_param = and_&lt;dash_prime, prime_num&gt;;</div><div class="line"><span class="keyword">using</span> parameter = or_&lt;color_param, prime_param&gt;;</div></div><!-- fragment --><p>The <code>parameter</code> maybe either <code>--prime=&lt;prime_num&gt;</code> or <code>--color=&lt;rgb&gt;</code>. <code>&lt;prime_num&gt;</code> and <code>&lt;rgb&gt;</code> maybe either <code>red, green</code> or <code>blue</code> and <code>1, 3</code> or <code>5</code> respectively. This example uses a mixture of preprocessor macros and template aliases to define the grammar. The C++ representation is more verbose due to C++ language requirements but it maps to the BNF line-for-line.</p>
<p>Using this specification to parse command line parameters is a matter of passing the start rule and string to a parser:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[]){</div><div class="line">    std::string sParam = argv[1];</div><div class="line">    <span class="keyword">auto</span> oAST = <a class="code" href="classxtd_1_1parser.html">xtd::parser&lt;parameter&gt;::parse</a>(sParam.begin(), sParam.end());</div><div class="line">    <span class="keywordflow">if</span> (!oAST){</div><div class="line">        <span class="comment">//parse failed, show usage or error</span></div><div class="line">    }<span class="keywordflow">else</span>{</div><div class="line">        <span class="comment">//work with parsed parameters</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Done and done.</p>
<h2>AST Generation </h2>
<p>An AST is instantated and returned by <code><a class="el" href="classxtd_1_1parser.html">xtd::parser</a>&lt;&gt;::parse()</code> when the parse is successful. The AST is an object model that represents the parsed grammar. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 11 2016 13:44:56 for XTL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
