<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>XTL: Template Basics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XTL
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">eXtended Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__src_github_xtl_docs__template-_basics.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Template Basics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Preface </h2>
<p>The progression of modern C++ can be described as evolving through two distinct paradigms. First from the legacy C to object-oriented C++ with classes. The modern paradigm can be described as a shift toward <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">Template Meta Programming</a>.</p>
<p>Meta-Programming differs from conventional programming in a number of ways. A prominent distinction is that meta-programming is more accurately programming the compiler how and what to compile rather than programming a processor what to execute. Meta-programming closely interacts with the compiler typically before machine code is generated. It is close interaction with the compiler that makes meta-programming the preferential platform of generic library developers.</p>
<blockquote class="doxtable">
<p>It's worth noting that I make a distinction between generic and object-oriented. In this context, generic programming may or may not be OO while OO is not generic. OO refers to concrete or abstract class types while generic programming is more or less type-less.</p>
<p></p>
</blockquote>
<p>The C++ template engine is a <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing Complete</a> "language" within C++ that continues to grow and yield powerful new language extensions with each adopted revision of the language standard. Because the features were an after-thought and more or less discovered by accident, the syntax is cumbersome, unfamiliar and non-intuitive. It requires significant dedication to navigate the plethora of caveats but the payoffs can be significant.</p>
<p>The goal of this informative is to shed light on the C++ template engine and present the topic in an easy to understand format with descriptive examples, each step building on the prior. This work will by no means be a complete corpus on this lengthy topic. The intent is to be a spring-board by which some basic knowledge can be derived. See the 'Suggested Reading' section at the bottom of this page for more detailed information.</p>
<h2>Template Basics </h2>
<p>At it's most basic level, templates permit a generic or type-less algorithm to work with various concrete types. When a template is used the compiler will qualify the generic types into the concrete types required to run. For example, here's a simple function template: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty&gt; _Ty square(_Ty src){ <span class="keywordflow">return</span> src * src; }</div>
</div><!-- fragment --><p> This function template can be reused to square shorts, ints, longs, doubles or any other type that supports operator *. The compiler will substitute the <code>_Ty</code> parameter with other concrete types at compile time to <em>generate</em> the various overloaded versions of the function. Consider the following usage scenarios:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> cVal = 8;</div>
<div class="line"><span class="keywordtype">int</span> iVal = 123;</div>
<div class="line"><span class="keywordtype">double</span> dVal = 3.14;</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; square&lt;char&gt;(cVal) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; square&lt;int&gt;(iVal) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; square&lt;double&gt;(dVal) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The compiler will substitute the generic _Ty parameter with a char, int and double respectively to generate the following specializations:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> square(<span class="keywordtype">char</span> src){ <span class="keywordflow">return</span> src * src; }</div>
<div class="line"><span class="keywordtype">int</span> square(<span class="keywordtype">int</span> src){ <span class="keywordflow">return</span> src * src; }</div>
<div class="line"><span class="keywordtype">double</span> square(<span class="keywordtype">double</span> src){ <span class="keywordflow">return</span> src * src; }</div>
</div><!-- fragment --><p> The above three <em>specializaitons</em> are generated by the compiler based on the usage scenarios despite the single instance of the <code>square</code> function template in code. This feature can obviously save a lot of typing and technical debit when a single definition needs maintaining instead of three. The notable take-away from TMP at this point is <b>code generation</b>.</p>
<p>The above specializations are qualified with the type surrounded in angle brackets. (e.g. square&lt;<b>char</b>&gt;) Function templates have a special ability to evaluate certain parameter types based on usage scenarios. The above template can be simplified: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty&gt; <span class="keyword">auto</span> square(_Ty src) -&gt; _Ty { <span class="keywordflow">return</span> src * src; }</div>
</div><!-- fragment --><p> In this example, the <code>auto</code> keyword is a placeholder ordering the compiler to evaluate the type at a later time. This new version of <code>square</code> can be used without the type qualifiers: </p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> cVal = 8;</div>
<div class="line"><span class="keywordtype">int</span> iVal = 123;</div>
<div class="line"><span class="keywordtype">double</span> dVal = 3.14;</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; square(cVal) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; square(iVal) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; square(dVal) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Here the types are unambiguous because they can be deduced based on the usage scenario so there's no need to qualify them. If the type cannot be deduced based on the usage scenario it must be qualified in the template parameter list. Within the definition of the specialization the parameters must be listed in the order that they're declared. </p>
<h3>Class Templates</h3>
<p>The previous examples demonstrate <em>function templates</em>. <em>Class templates</em> are another template variation: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty&gt; <span class="keyword">struct </span>CheckedPointer{</div>
<div class="line">    CheckedPointer(_Ty * newval) : _Ptr(newval){}</div>
<div class="line">    _Ty * operator-&gt;() { assert(_Ptr); <span class="keywordflow">return</span> _Ptr; }</div>
<div class="line">    <span class="keywordtype">void</span> delete_it(){</div>
<div class="line">        <span class="keyword">delete</span> _Ptr;</div>
<div class="line">        _Ptr = <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line">    _Ty * _Ptr;</div>
<div class="line">};</div>
</div><!-- fragment --><p> This is a very simple class template that checks if the contained pointer to type _Ty is not null during every access. This template could be used in code like: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="keyword">struct </span>user{</div>
<div class="line">        <span class="keywordtype">int</span> userid;</div>
<div class="line">        <span class="keywordtype">int</span> lastlogin;</div>
<div class="line">    };</div>
<div class="line">    CheckedPointer&lt;user&gt; oUser(<span class="keyword">new</span> user);</div>
<div class="line">    oUser-&gt;userid = 1234;</div>
<div class="line">    oUser-&gt;delete_it();</div>
<div class="line">    oUser-&gt;lastlogin = 111980; <span class="comment">//assert</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h3>Type and Non-Type Parameters</h3>
<p>Templates can accept type and non-type parameters. Type parameters refer to all the compiler intrinsic and user defined types such as classes and structures. Compiler intrinsics are identified with keywords such as <code>int</code>, <code>short</code>, <code>double</code>, etc. Non-type parameters included values that can be evaluated at compile time such as static constant pointers and references.</p>
<p>Here's an example of a class template that accepts a type and non-type template parameters: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keywordtype">size_t</span> _Dims&gt; <span class="keyword">struct </span>StaticArray{</div>
<div class="line">    _Ty value[_Dims];</div>
<div class="line">};</div>
</div><!-- fragment --><p> This very simply declares a fixed sized array. It's of little use but can be used in code as: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    StaticArray&lt;int, 10&gt; oArr;</div>
<div class="line">    oArr.value[0] = 123;</div>
<div class="line">    <span class="keywordflow">return</span> oArr.value[0];</div>
<div class="line">}</div>
</div><!-- fragment --><p> The first parameter is a type parameter, the second is a non-type parameter. Here's another example that pre-computes a value: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keywordtype">size_t</span> _Dims&gt; <span class="keyword">struct </span>StaticArray{</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> EvenNumberOfElements = (0 == ( _Dims %2 ));</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> Here the template engine performs the division and comparison at compile time and stores the result in the static constant. This consumes no clock cycles at run-time to calculate. Integral types can be calculated with ease by the template engine and leveraged in various ways to achieve significant run-time performance improvements. This is the name of the game with TMP: interacting with the compiler to generate, pre-compute and pre-compile as much as possible to reduce run-time overhead and reduce the volume of maintainable code. </p>
<h2>Specialization </h2>
<p>The generic form of a function template is declared with the following convention:</p>
<p>[</p>
<div class="image">
<img src="FunctionTemplateDeclaration.png" alt="FunctionTemplateDeclaration.png"/>
<div class="caption">
Function Template Declaration</div></div>
<p>]</p>
<p>A class template is almost identical:</p>
<p>[</p>
<div class="image">
<img src="ClassTemplateDeclaration.png" alt="ClassTemplateDeclaration.png"/>
<div class="caption">
Class Template Declaration</div></div>
<p>]</p>
<p>The input parameters on the generic form appear on the left-hand-side of the template name.</p>
<p>A class or function template is specialized when a generic parameter is explicitly qualified in a declaration. For example, assume a compile-time constant is calculated: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> _Factor&gt; <span class="keywordtype">int</span> Factoral(){</div>
<div class="line">  <span class="keywordflow">return</span> _Factor * Factoral&lt;_Factor - 1&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is a function template that calculates <code>value</code> at compile time by recursively multiplying the value of the <code>_Factor</code> parameter by <code>_Factor-1</code>. At first glance this may seem correct, however, there's at least two problems with it. First, at some point during the recursive calculation the value of _Factor will reach zero and invalidate the computation (anything multiplied by zero is zero). Next, there is no terminating condition for the recursive calls so the compile will fail at some point due to infinite recursion. For this function to operate as expected a specialization is introduced that terminates the recursion and corrects the calculation: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keywordtype">int</span> Factoral&lt;1&gt;(){</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The fully specialized form of a function template is declared with the following convention:</p>
<p>[</p>
<div class="image">
<img src="FunctionTemplateSpecialization.png" alt="FunctionTemplateSpecialization.png"/>
<div class="caption">
Function Template Specialization</div></div>
<p>]</p>
<p>And a class template is almost identical:</p>
<p>[</p>
<div class="image">
<img src="ClassTemplateSpecialization.png" alt="ClassTemplateSpecialization.png"/>
<div class="caption">
Class Template Specialization</div></div>
<p>]</p>
<p>Notice the specialized values appear on the right-hand-side of the template name. This distinguishes specialized templates from their generic form. Input parameters appear to the left of the name while output parameters appear to the right.</p>
<p>During compilation, the compiler chooses the <em>most specialized</em> version of a template over a lesser specialized version whenever multiple are encountered. In this case, the specialized <code>template &lt;&gt; struct Factoral&lt;1&gt;</code> is more specialized than the generic <code>template &lt;size_t _Factor&gt; struct Factoral</code> so the compiler chooses it while recursively calculating the value. Assume this function template is used as: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <span class="keywordflow">return</span> Factoral&lt;5&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p> The compiler generate 4 specializations before instantiating the explicit Factoral&lt;1&gt; specialization. Here is an excerpt of the listing file generated by MSVC14 with debugging enabled: </p>
<div class="fragment"><div class="line">PUBLIC  ??$Factoral@$04@@YAHXZ        ; Factoral&lt;5&gt;</div>
<div class="line">PUBLIC  ??$Factoral@$03@@YAHXZ        ; Factoral&lt;4&gt;</div>
<div class="line">PUBLIC  ??$Factoral@$02@@YAHXZ        ; Factoral&lt;3&gt;</div>
<div class="line">PUBLIC  ??$Factoral@$01@@YAHXZ        ; Factoral&lt;2&gt;</div>
<div class="line">PUBLIC  ??$Factoral@$00@@YAHXZ        ; Factoral&lt;1&gt;</div>
</div><!-- fragment --><p> <code>Factoral&lt;5&gt;</code> through <code>Factoral&lt;2&gt;</code> are compiler generated specializations that will be called in the expected order. The beauty of TMP can be demonstrated in the listing of the release build. Since the values are deterministic at compile-time, the optimizer eliminates it all: </p>
<div class="fragment"><div class="line">; <span class="keywordtype">int</span> main() {</div>
<div class="line">; <span class="keywordflow">return</span> Factoral&lt;5&gt;();</div>
<div class="line">00E11000  mov         eax,78h  </div>
<div class="line">00E11005  ret  </div>
</div><!-- fragment --><p>The only run-time code that is generated is to return the result of the compile-time calculation. None of the heavy lifting is done at run-time so we get excellent performance gains. Today's optimizers are very complex and to leverage their full potential, template meta-programs perform as much compile-time computation as possible.</p>
<h2>Partial Specialization </h2>
<p>When a template is fully specialized, all the output parameters are explicitly specified to fully qualify the generic form's input parameters. Partial specialization, as the name implies, specialize only a portion of the output parameters while others may be implicitly deducible by the compiler. This permits a specialized template to have a specific set of behaviors for a target group of instances while other instances may have different behaviors.</p>
<p>Partial specializations have the following form:</p>
<p>[</p>
<div class="image">
<img src="ClassTemplateSpecialization.png" alt="ClassTemplateSpecialization.png"/>
<div class="caption">
Class Template Specialization</div></div>
<p>]</p>
<p>The output parameters of specializations must match the order of inputs on the generic form but the input parameters don't have to.</p>
<p>Here's an example of partial specialization: ```{.cpp} struct Widget{ static const int Cost = 3; }; struct Snafoo{ static const int Cost = 5; }; struct Fizzbang{ static const int Cost = 7; }; template &lt;typename _Ty, int _Quantity&gt; struct Order{ static const int Total = _Ty::Cost * _Quantity; }; template &lt;typename _ty&gt;=""&gt; struct Order&lt;_Ty, 10&gt;{ static const int Total = _Ty::Cost * 10 - 5; }; int main(int argc, char * argv[]){ std::cout &lt;&lt; "Order&lt;Widget, 5&gt;::Total : " &lt;&lt; Order&lt;Widget, 5&gt;::Total &lt;&lt; std::endl; std::cout &lt;&lt; "Order&lt;Snafoo, 5&gt;::Total : " &lt;&lt; Order&lt;Snafoo, 5&gt;::Total &lt;&lt; std::endl; std::cout &lt;&lt; "Order&lt;Fizzbang, 5&gt;::Total : " &lt;&lt; Order&lt;Fizzbang, 5&gt;::Total &lt;&lt; std::endl; std::cout &lt;&lt; "Order&lt;Widget, 10&gt;::Total : " &lt;&lt; Order&lt;Widget, 10&gt;::Total &lt;&lt; std::endl; std::cout &lt;&lt; "Order&lt;Snafoo, 10&gt;::Total : " &lt;&lt; Order&lt;Snafoo, 10&gt;::Total &lt;&lt; std::endl; std::cout &lt;&lt; "Order&lt;Fizzbang, 10&gt;::Total : " &lt;&lt; Order&lt;Fizzbang, 10&gt;::Total &lt;&lt; std::endl; return oConfig.Total; } ``` This app calculates the total cost of an order. The partial specialization produces a $5 discount when 10 items are ordered. The first three outputs are: ``` Order&lt;Widget, 5&gt;::Total : 15 Order&lt;Snafoo, 5&gt;::Total : 25 Order&lt;Fizzbang, 5&gt;::Total : 35 ``` The last three outputs are: ``` Order&lt;Widget, 10&gt;::Total : 25 Order&lt;Snafoo, 10&gt;::Total : 45 Order&lt;Fizzbang, 10&gt;::Total : 65 ``` During the type deduction phase, the compiler chooses the <em>most specialized</em> variation of a template to instantiate and expand. Order&lt;Widget, 10&gt;, Order&lt;Snafoo, 10&gt; and Order&lt;Fizzbang, 10&gt; match both form of the Order templates but the partial specialization is <em>more specialized</em> than the generic form so the compiler chooses it to instantiate during type deduction.</p>
<h2>Suggested Reading </h2>
<ul>
<li><a href="https://www.amazon.com/Advanced-Metaprogramming-Classic-Davide-Gennaro/dp/1484210115">Advanced Metaprogramming in Classic C++</a></li>
<li><a href="https://www.amazon.com/Templates-Complete-Guide-David-Vandevoorde/dp/0201734842">C++ Templates: The Complete Guide</a></li>
<li><a href="https://www.amazon.com/Template-Metaprogramming-Concepts-Techniques-Beyond/dp/0321227255">C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond</a></li>
<li><a href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</a></li>
<li><a href="https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315">Modern C++ Design: Generic Programming and Design Patterns Applied</a></li>
</ul>
<p>Copyright :copyright: David Mott 2016 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 9 2016 20:08:25 for XTL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
