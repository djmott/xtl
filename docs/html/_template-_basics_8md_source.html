<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>XTL: Template-Basics.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_tiny.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XTL
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">eXtended Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_template-_basics_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Template-Basics.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Template Basics</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;===============</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Preface</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;-------</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The progression of modern C++ can be described as evolving through two distinct paradigms. First from the legacy C to object-oriented C++ with classes. The modern paradigm can be described as a shift toward [Template Meta Programming](https://en.wikipedia.org/wiki/Template_metaprogramming).</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Meta-Programming differs from conventional programming in a number of ways.  A prominent distinction is that meta-programming is more accurately programming the compiler how and what to compile rather than programming a processor what to execute. Meta-programming closely interacts with the compiler typically before machine code is generated. It is close interaction with the compiler that makes meta-programming the preferential platform of generic library developers.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;&gt; It&#39;s worth noting that I make a distinction between generic and object-oriented. In this context, generic programming may or may not be OO while OO is not generic. OO refers to concrete or abstract class types while generic programming is more or less type-less.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;The C++ template engine is a [Turing Complete](https://en.wikipedia.org/wiki/Turing_completeness) &quot;language&quot; within C++ that continues to grow and yield powerful new language extensions with each adopted revision of the language standard. Because the features were an after-thought and more or less discovered by accident, the syntax is cumbersome, unfamiliar and non-intuitive. It requires significant dedication to navigate the plethora of caveats but the payoffs can be significant.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;The goal of this informative is to shed light on the C++ template engine and present the topic in an easy to understand format with descriptive examples, each step building on the prior. This work will by no means be a complete corpus on this lengthy topic. The intent is to be a spring-board by which some basic knowledge can be derived. See the &#39;Suggested Reading&#39; section at the bottom of this page for more detailed information. </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Template Basics</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;---------------</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;At it&#39;s most basic level, templates permit a generic or type-less algorithm to work with various concrete types. When a template is used the compiler will qualify the generic types into the concrete types required to run. For example, here&#39;s a simple function template:</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;~~~{.c}</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;template &lt;typename _Ty&gt; _Ty square(_Ty src){ return src * src; }</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;~~~</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;This function template can be reused to square shorts, ints, longs, doubles or any other type that supports operator *.  The compiler will substitute the `_Ty` parameter with other concrete types at compile time to _generate_ the various overloaded versions of the function. Consider the following usage scenarios:</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;~~~{.c}</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;char cVal = 8;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;int iVal = 123;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;double dVal = 3.14;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;std::cout &lt;&lt; square&lt;char&gt;(cVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;std::cout &lt;&lt; square&lt;int&gt;(iVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;std::cout &lt;&lt; square&lt;double&gt;(dVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;~~~</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;The compiler will substitute the generic _Ty parameter with a char, int and double respectively to generate the following specializations:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;~~~{.c}</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;char square(char src){ return src * src; }</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;int square(int src){ return src * src; }</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;double square(double src){ return src * src; }</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;~~~</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;The above three *specializaitons* are generated by the compiler based on the usage scenarios despite the single instance of the `square` function template in code. This feature can obviously save a lot of typing and technical debit when a single definition needs maintaining instead of three. The notable take-away from TMP at this point is **code generation**.</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;The above specializations are qualified with the type surrounded in angle brackets. (e.g. square&lt;**char**&gt;) Function templates have a special ability to evaluate certain parameter types based on usage scenarios. The above template can be simplified:</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;~~~{.c}</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;template &lt;typename _Ty&gt; auto square(_Ty src) -&gt; _Ty { return src * src; }</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;~~~</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;In this example, the `auto` keyword is a placeholder ordering the compiler to evaluate the type at a later time.  This new version of `square` can be used without the type qualifiers:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;~~~{.c}</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;char cVal = 8;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;int iVal = 123;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;double dVal = 3.14;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;std::cout &lt;&lt; square(cVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;std::cout &lt;&lt; square(iVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;std::cout &lt;&lt; square(dVal) &lt;&lt; std::endl;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;~~~</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;Here the types are unambiguous because they can be deduced based on the usage scenario so there&#39;s no need to qualify them. If the type cannot be deduced based on the usage scenario it must be qualified in the template parameter list. Within the definition of the specialization the parameters must be listed in the order that they&#39;re declared.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;### Class Templates</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;The previous examples demonstrate _function templates_. _Class templates_ are another template variation:</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;~~~{.c}</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;template &lt;typename _Ty&gt; struct CheckedPointer{</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    CheckedPointer(_Ty * newval) : _Ptr(newval){}</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    _Ty * operator-&gt;() { assert(_Ptr); return _Ptr; }</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    void delete_it(){</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        delete _Ptr;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        _Ptr = nullptr;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    _Ty * _Ptr;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;};</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;~~~</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;This is a very simple class template that checks if the contained pointer to type _Ty is not null during every access. This template could be used in code like:</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~{.c}</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;int main(){</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    struct user{</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        int userid;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;        int lastlogin;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    };</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    CheckedPointer&lt;user&gt; oUser(new user);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    oUser-&gt;userid = 1234;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    oUser-&gt;delete_it();</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    oUser-&gt;lastlogin = 111980; //assert</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;}</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;~~~</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;### Type and Non-Type Parameters</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;Templates can accept type and non-type parameters. Type parameters refer to all the compiler intrinsic and user defined types such as classes and structures. Compiler intrinsics are identified with keywords such as `int`, `short`, `double`, etc.  Non-type parameters included values that can be evaluated at compile time such as static constant pointers and references.</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;Here&#39;s an example of a class template that accepts a type and non-type template parameters:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;~~~{.c}</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;template &lt;typename _Ty, size_t _Dims&gt; struct StaticArray{</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    _Ty value[_Dims];</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;};</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;~~~</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;This very simply declares a fixed sized array. It&#39;s of little use but can be used in code as:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;~~~{.c}</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;int main(){</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    StaticArray&lt;int, 10&gt; oArr;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    oArr.value[0] = 123;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    return oArr.value[0];</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;}</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;~~~</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;The first parameter is a type parameter, the second is a non-type parameter. Here&#39;s another example that pre-computes a value:</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;~~~{.c}</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;template &lt;typename _Ty, size_t _Dims&gt; struct StaticArray{</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    static const bool EvenNumberOfElements = (0 == ( _Dims %2 ));</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    ...</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;};</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;~~~</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;Here the template engine performs the division and comparison at compile time and stores the result in the static constant. This consumes no clock cycles at run-time to calculate. Integral types can be calculated with ease by the template engine and leveraged in various ways to achieve significant run-time performance improvements. This is the name of the game with TMP: interacting with the compiler to generate, pre-compute and pre-compile as much as possible to reduce run-time overhead and reduce the volume of maintainable code. </div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;Specialization</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;--------------</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;The generic form of a function template is declared with the following convention:</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;[![Function Template Declaration](images/FunctionTemplateDeclaration.png)]</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;A class template is almost identical:</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;[![Class Template Declaration](images/ClassTemplateDeclaration.png)]</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;The input parameters on the generic form appear on the left-hand-side of the template name.</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;A class or function template is specialized when a generic parameter is explicitly qualified in a declaration. For example, assume a compile-time constant is calculated:</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;~~~{.c}</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;template &lt;int _Factor&gt; int Factoral(){</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  return _Factor * Factoral&lt;_Factor - 1&gt;();</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;}</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;~~~</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;This is a function template that calculates `value` at compile time by recursively multiplying the value of the `_Factor` parameter by `_Factor-1`. At first glance this may seem correct, however, there&#39;s at least two problems with it. First, at some point during the recursive calculation the value of _Factor will reach zero and invalidate the computation (anything multiplied by zero is zero). Next, there is no terminating condition for the recursive calls so the compile will fail at some point due to infinite recursion. For this function to operate as expected a specialization is introduced that terminates the recursion and corrects the calculation:</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;~~~{.c}</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;template &lt;&gt; int Factoral&lt;1&gt;(){</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  return 1;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;~~~</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;The fully specialized form of a function template is declared with the following convention:</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;[![Function Template Specialization](images/FunctionTemplateSpecialization.png)]</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;And a class template is almost identical:</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;[![Class Template Specialization](images/ClassTemplateSpecialization.png)]</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Notice the specialized values appear on the right-hand-side of the template name.  This distinguishes specialized templates from their generic form. Input parameters appear to the left of the name while output parameters appear to the right.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;During compilation, the compiler chooses the _most specialized_ version of a template over a lesser specialized version whenever multiple are encountered. In this case, the specialized  `template &lt;&gt; struct Factoral&lt;1&gt;` is more specialized than the generic `template &lt;size_t _Factor&gt; struct Factoral` so the compiler chooses it while recursively calculating the value. Assume this function template is used as:</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;~~~{.c}</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;int main(){</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  return Factoral&lt;5&gt;();</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;}</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;~~~</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;The compiler generate 4 specializations before instantiating the explicit Factoral&lt;1&gt; specialization. Here is an excerpt of the listing file generated by MSVC14 with debugging enabled:</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;~~~{.asm}</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;PUBLIC ??$Factoral@$04@@YAHXZ        ; Factoral&lt;5&gt;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;PUBLIC ??$Factoral@$03@@YAHXZ        ; Factoral&lt;4&gt;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;PUBLIC ??$Factoral@$02@@YAHXZ        ; Factoral&lt;3&gt;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;PUBLIC ??$Factoral@$01@@YAHXZ        ; Factoral&lt;2&gt;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;PUBLIC ??$Factoral@$00@@YAHXZ        ; Factoral&lt;1&gt;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;~~~</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;`Factoral&lt;5&gt;` through `Factoral&lt;2&gt;` are compiler generated specializations that will be called in the expected order. The beauty of TMP can be demonstrated in the listing of the release build. Since the values are deterministic at compile-time, the optimizer eliminates it all:</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;~~~{.c}</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;; int main() {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;; return Factoral&lt;5&gt;();</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;00E11000  mov         eax,78h  </div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;00E11005  ret  </div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;~~~</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;The only run-time code that is generated is to return the result of the compile-time calculation. None of the heavy lifting is done at run-time so we get excellent performance gains. Today&#39;s optimizers are very complex and to leverage their full potential, template meta-programs perform as much compile-time computation as possible.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;Partial Specialization</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;----------------------</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;When a template is fully specialized, all the output parameters are explicitly specified to fully qualify the generic form&#39;s input parameters. Partial specialization, as the name implies, specialize only a portion of the output parameters while others may be implicitly deducible by the compiler. This permits a specialized template to have a specific set of behaviors for a target group of instances while other instances may have different behaviors.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;Partial specializations have the following form:</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;[![Class Template Specialization](images/ClassTemplateSpecialization.png)]</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;The output parameters of specializations must match the order of inputs on the generic form but the input parameters don&#39;t have to.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;Here&#39;s an example of partial specialization:</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;```{.cpp}</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;struct Widget{</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  static const int Cost = 3;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;};</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;struct Snafoo{</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  static const int Cost = 5;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;};</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;struct Fizzbang{</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  static const int Cost = 7;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;};</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;template &lt;typename _Ty, int _Quantity&gt; struct Order{</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  static const int Total = _Ty::Cost * _Quantity;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;};</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;template &lt;typename _Ty&gt; struct Order&lt;_Ty, 10&gt;{</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  static const int Total = _Ty::Cost * 10 - 5;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;};</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;int main(int argc, char * argv[]){</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Widget, 5&gt;::Total : &quot; &lt;&lt; Order&lt;Widget, 5&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Snafoo, 5&gt;::Total : &quot; &lt;&lt; Order&lt;Snafoo, 5&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Fizzbang, 5&gt;::Total : &quot; &lt;&lt; Order&lt;Fizzbang, 5&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Widget, 10&gt;::Total : &quot; &lt;&lt; Order&lt;Widget, 10&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Snafoo, 10&gt;::Total : &quot; &lt;&lt; Order&lt;Snafoo, 10&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  std::cout &lt;&lt; &quot;Order&lt;Fizzbang, 10&gt;::Total : &quot; &lt;&lt; Order&lt;Fizzbang, 10&gt;::Total &lt;&lt; std::endl;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  return oConfig.Total;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;}</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;```</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;This app calculates the total cost of an order. The partial specialization produces a $5 discount when 10 items are ordered. The first three outputs are:</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;```</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;Order&lt;Widget, 5&gt;::Total : 15</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;Order&lt;Snafoo, 5&gt;::Total : 25</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;Order&lt;Fizzbang, 5&gt;::Total : 35</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;```</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;The last three outputs are:</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;```</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;Order&lt;Widget, 10&gt;::Total : 25</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;Order&lt;Snafoo, 10&gt;::Total : 45</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;Order&lt;Fizzbang, 10&gt;::Total : 65</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;```</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;During the type deduction phase, the compiler chooses the _most specialized_ variation of a template to instantiate and expand. Order&lt;Widget, 10&gt;, Order&lt;Snafoo, 10&gt; and Order&lt;Fizzbang, 10&gt; match both form of the Order templates but the partial specialization is _more specialized_ than the generic form so the compiler chooses it to instantiate during type deduction.</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;Suggested Reading</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;-----------------    </div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160; * [Advanced Metaprogramming in Classic C++](https://www.amazon.com/Advanced-Metaprogramming-Classic-Davide-Gennaro/dp/1484210115) </div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160; * [C++ Templates: The Complete Guide](https://www.amazon.com/Templates-Complete-Guide-David-Vandevoorde/dp/0201734842)</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160; * [C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond](https://www.amazon.com/Template-Metaprogramming-Concepts-Techniques-Beyond/dp/0321227255)</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160; * [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996)</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160; * [Modern C++ Design: Generic Programming and Design Patterns Applied](https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315)</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;Copyright :copyright: David Mott 2016  </div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Template-Basics.md</b></li>
    <li class="footer">Generated on Tue Jul 26 2016 11:34:47 for XTL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
